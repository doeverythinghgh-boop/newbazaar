  
<style>
  /* Main ad banner container */
  #advertisement-section {
    position: relative;
    height: 20vh;
    min-height: 150px;
    margin-bottom: 10px;
    overflow: hidden;
    background: linear-gradient(180deg, var(--bg-color-white) 0%, var(--border-color) 100%);
    width: auto;
    box-shadow: var(--shadow-interactive);
    margin-left: 15px;
    margin-right: 15px;
    border-radius: 12px;
  }

  /* Inner slides container */
  .ad-slider-track {
    position: relative;
    transform-style: preserve-3d;
    perspective: 1000px;
    width: 100%;
    height: 100%;
  }

  /* Each ad slide */
  .ad-slide {
    position: absolute;
    top: 5%;
    left: 20%;
    width: 60%;
    height: 100%;
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    border-radius: 12px;
    box-shadow: var(--shadow-interactive);
    opacity: 0.8;
    transition: transform 0.8s cubic-bezier(0.4, 0, 0.2, 1), filter 0.8s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.8s cubic-bezier(0.4, 0, 0.2, 1);
    z-index: 1;
    filter: blur(3px) brightness(0.7) saturate(0.5);
    cursor: pointer;
  }

  /* Active (visible) slide */
  .ad-slide.active {
    transform: translateX(0) scale(1) !important;
    filter: blur(0) brightness(1) saturate(1);
    opacity: 1;
    z-index: 2;
  }

  /* Navigation dots container */
  .ad-slider-dots {
    position: absolute;
    background-color: transparent;
    color: transparent;
    bottom: 5px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 10px;
    z-index: 3;
  }

  /* Each navigation dot */
  .ad-slider-dot {
    width: 5px;
    height: 5px;
    border-radius: 50%;
    background-color: var(--text-color-light);
    border: 1px solid rgba(0, 0, 0, 0.1);
    cursor: pointer;
    transition: background-color 0.3s, transform 0.3s;
  }

  /* Active dot */
  .ad-slider-dot.active {
    background-color: var(--bg-color-white);
    transform: scale(1.2);
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
  }

  /* No ads message */
  .no-ads-message {
    text-align: center;
    padding: 20px;
    color: var(--secondary-color);
    font-family: "Tajawal", sans-serif;
  }

  /* Navigation buttons (Prev/Next) styles */
  .ad-slider-nav {
    position: absolute;
    bottom: 2px;
    transform: translateY(-50%);
    z-index: 3;
    background-color: transparent;
    color: var(--bg-color-light);
    border: none;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    font-size: 18px;
    cursor: pointer;
    display: none; /* Hidden by default */
    align-items: center;
    justify-content: center;
    transition: background-color 0.3s, transform 0.2s;
  }

  .ad-slider-nav.prev {
    left: 15px;
  }

  .ad-slider-nav.next {
    right: 15px;
  }

  /* Effect on button press */
  .ad-slider-nav:active {
    background-color: rgba(0, 0, 0, 0.5);
    transform: translateY(-50%) scale(0.95);
  }
</style>
  <!-- ✅ جديد: حاوية شريط الإعلانات -->
    <div id="advertisement-section" class="ad-slider-container">
      <p class="no-ads-message" style="display: none">لا توجد إعلانات حالياً</p>
      <div class="ad-slider-track"></div>
      <div class="ad-slider-dots"></div>
      <button
        class="ad-slider-nav prev"
        aria-label="Previous Slide"
        style="display: none"
      >
        <i class="fas fa-chevron-left"></i>
      </button>
      <button
        class="ad-slider-nav next"
        aria-label="Next Slide"
        style="display: none"
      >
        <i class="fas fa-chevron-right"></i>
      </button>
    </div>
    <script>
      /**
 * @file js/adverModule.js
 * @description موديول لعرض شريط إعلانات متحرك (Hero Slider).
 *
 * يقوم هذا الموديول بجلب الصور الإعلانية من رابط عام وعرضها
 * في حاوية محددة كشريط إعلاني ينتقل تلقائيًا.
 */


/**
 * @description يجلب آخر تاريخ تحديث مسجل في جدول `updates` من واجهة برمجة التطبيقات (API).
 * @returns {Promise<Object|null>} - وعد (Promise) يحتوي على كائن يتضمن تاريخ التحديث (`{ datetime: '...' }`)، أو `null` في حالة الفشل أو عدم وجود تحديثات.
 * @throws {Error} - إذا فشل جلب البيانات من API.
 */
async function getLatestUpdate() {
  try {
    const data = await apiFetch('/api/updates', {
      specialHandlers: {
        404: () => ({ datetime: null }) // Not a fatal error
      }
    });
    return data;
  } catch (error) {
    console.error("%c[getLatestUpdate] failed:", "color: red;", error);
    return null;
  }
}

/**
 * @description تهيئة وعرض موديول الإعلانات.
 *   يقوم بجلب الصور الإعلانية من الذاكرة المؤقتة المحلية أو من الخادم، ثم يقوم ببناء وعرض شريط تمرير (Slider) للإعلانات.
 *   يدعم آلية التخزين المؤقت لتجنب جلب البيانات بشكل متكرر.
 * @param {HTMLElement} container - عنصر DOM الذي سيحتوي على شريط الإعلانات.
 * @param {boolean} [forceRefresh=false] - إذا كان `true`، سيتم تجاوز الذاكرة المؤقتة وجلب الإعلانات من الخادم مباشرة.
 * @returns {Promise<void>} - وعد (Promise) لا يُرجع قيمة عند الاكتمال.
 * @see getLatestUpdate
 * @see buildSlider
 */
async function initAdverModule(container, forceRefresh = false) {
  if (!container) {
    console.error(`[AdverModule] لم يتم توفير عنصر الحاوية.`);
    return;
  }

  console.log('%c[AdverModule] Initializing...', 'color: #20c997');

  // --- ✅ جديد: منطق التخزين المؤقت (Caching) ---
  const CACHE_KEY_IMAGES = 'adver_images_cache';
  const CACHE_KEY_TIMESTAMP = 'adver_timestamp_cache';
  const CACHE_KEY_LAST_CHECK = 'adver_last_check_timestamp'; // ✅ جديد: لتخزين وقت آخر فحص
  const CHECK_INTERVAL = 24 * 60 * 60 * 1000; // 24 ساعة بالمللي ثانية

  const cachedTimestamp = localStorage.getItem(CACHE_KEY_TIMESTAMP);
  const cachedImages = JSON.parse(localStorage.getItem(CACHE_KEY_IMAGES));
  const lastCheckTimestamp = localStorage.getItem(CACHE_KEY_LAST_CHECK);

  // ✅ جديد: التحقق مما إذا كان يجب استخدام النسخة المخبأة دون الاتصال بالخادم
  if (!forceRefresh && lastCheckTimestamp && (Date.now() - lastCheckTimestamp < CHECK_INTERVAL) && cachedImages && cachedImages.length > 0) {
    console.log('%c[AdverModule] Loading ads from cache (within 24h interval).', 'color: green; font-weight: bold;');
    buildSlider(container, cachedImages);
    return; // توقف هنا، لا حاجة للاتصال بالخادم
  }

  // جلب آخر تاريخ تحديث من الخادم
  console.log('%c[AdverModule] Checking for updates from server (interval elapsed or no cache).', 'color: #17a2b8;');
  const latestUpdate = await getLatestUpdate();
  const serverTimestamp = latestUpdate ? latestUpdate.datetime : null;

  console.log(`[AdverModule] Server Timestamp: ${serverTimestamp}`);
  console.log(`[AdverModule] Cached Timestamp: ${cachedTimestamp}`);

  // إذا كانت التواريخ متطابقة وهناك صور محفوظة، استخدم النسخة المحفوظة (بعد التحقق من الخادم)
  if (!forceRefresh && serverTimestamp && serverTimestamp === cachedTimestamp && cachedImages && cachedImages.length > 0) {
    console.log('%c[AdverModule] Loading ads from cache.', 'color: green; font-weight: bold;');
    localStorage.setItem(CACHE_KEY_LAST_CHECK, Date.now()); // ✅ جديد: تحديث وقت آخر فحص
    buildSlider(container, cachedImages);
    return; // توقف هنا، لا حاجة لجلب الصور من الشبكة
  }

  // --- إذا لم تتطابق التواريخ أو لا توجد نسخة محفوظة، قم بالجلب من الشبكة ---
  console.log('%c[AdverModule] Cache is outdated or empty. Fetching from network...', 'color: orange; font-weight: bold;');

  const R2_PUBLIC_URL = 'https://pub-e828389e2f1e484c89d8fb652c540c12.r2.dev';
  const MAX_ADS = 10; // أقصى عدد من الإعلانات للبحث عنه
  const fetchedImages = [];

  /**
   * @description دالة مساعدة للتحقق مما إذا كانت الصورة موجودة عن طريق محاولة تحميلها.
   * @param {string} url - عنوان URL للصورة للتحقق منها.
   * @inner
   * @returns {Promise<{exists: boolean, url: string}>} - وعد (Promise) يُرجع كائنًا يوضح ما إذا كانت الصورة موجودة أم لا، بالإضافة إلى عنوان URL.
   */
  function checkImage(url) {
    return new Promise(resolve => {
      const img = new Image();
      img.onload = () => resolve({ exists: true, url: url });
      img.onerror = () => resolve({ exists: false, url: url });
      img.src = url;
    });
  }

  // جلب الصور الموجودة بالتوازي لتحسين الأداء
  const imageChecks = [];
  for (let i = 1; i <= MAX_ADS; i++) {
    const imageUrl = `${R2_PUBLIC_URL}/pic${i}.webp`;
    imageChecks.push(checkImage(imageUrl));
  }

  const results = await Promise.all(imageChecks);
  results.forEach(result => {
    if (result.exists) fetchedImages.push(result.url);
  });

  // ✅ جديد: حفظ الصور الجديدة وتاريخ التحديث في localStorage
  console.log(`[AdverModule] Fetched ${fetchedImages.length} images. Caching results.`);
  localStorage.setItem(CACHE_KEY_IMAGES, JSON.stringify(fetchedImages));
  if (serverTimestamp) {
    localStorage.setItem(CACHE_KEY_TIMESTAMP, serverTimestamp);
  }
  localStorage.setItem(CACHE_KEY_LAST_CHECK, Date.now()); // ✅ جديد: تحديث وقت آخر فحص بعد جلب الصور

  buildSlider(container, fetchedImages);
}

/**
 * @description يبني ويعرض شريط تمرير (Slider) للصور الإعلانية داخل حاوية محددة.
 *   ينشئ الشرائح والنقاط وأزرار التنقل، ويدير الحركة التلقائية والتفاعلات اليدوية.
 * @function buildSlider
 * @param {string[]} adImages - مصفوفة من عناوين URL لصور الإعلانات.
 * @returns {void}
 * @see goToSlide
 * @see startAutoPlay
 * @see pauseAutoPlay
 * @see resetAutoPlay
 */
function buildSlider(container, adImages) {
  /** @param {HTMLElement} container - عنصر DOM الذي سيحتوي على شريط التمرير. */
  // إذا لم توجد صور، اعرض رسالة
  if (adImages.length === 0) {
    container.innerHTML = '<p class="no-ads-message">لا توجد إعلانات حالياً</p>';
    container.style.height = 'auto'; // ضبط الارتفاع
    return;
  }

  // بناء هيكل الشريط الإعلاني
  container.innerHTML = `
    <div class="ad-slider-track"></div>
    <div class="ad-slider-dots"></div>
    <!-- ✅ جديد: أزرار التنقل -->
    <button class="ad-slider-nav prev" aria-label="Previous Slide"><i class="fas fa-chevron-left"></i></button>
    <button class="ad-slider-nav next" aria-label="Next Slide"><i class="fas fa-chevron-right"></i></button>
  `;

  const track = container.querySelector('.ad-slider-track');
  const dotsContainer = container.querySelector('.ad-slider-dots');
  const slides = [];
  const dots = [];
  let currentIndex = 0;
  let autoPlayInterval = null; // ✅ جديد: متغير لتخزين مؤقت الحركة التلقائية

  const prevButton = container.querySelector('.ad-slider-nav.prev');
  const nextButton = container.querySelector('.ad-slider-nav.next');

  // إنشاء الشرائح والنقاط
  adImages.forEach((imageUrl, index) => {
    const slide = document.createElement('div');
    slide.className = 'ad-slide';
    slide.style.backgroundImage = `url(${imageUrl})`;
    track.appendChild(slide);

    // ✅ جديد: إضافة أحداث لإيقاف الحركة مؤقتًا عند الضغط المستمر
    slide.addEventListener('mousedown', pauseAutoPlay);
    slide.addEventListener('mouseup', startAutoPlay);
    slide.addEventListener('touchstart', pauseAutoPlay, { passive: true });
    slide.addEventListener('touchend', startAutoPlay);
    slides.push(slide);

    const dot = document.createElement('div');
    dot.className = 'ad-slider-dot';
    dot.addEventListener('click', () => goToSlide(index));
    dotsContainer.appendChild(dot);
    dots.push(dot);
  });

  /**
   * @description تنتقل إلى شريحة محددة وتطبق تأثير الكاروسيل الدائري.
   *   تقوم بحساب وتطبيق التحويلات (transform) لكل شريحة بناءً على موقعها الحالي.
   * @param {number} index - فهرس الشريحة المستهدفة.
   * @inner
   * @returns {void}
   */
  function goToSlide(index) {
    const newIndex = (index + slides.length) % slides.length;
    currentIndex = newIndex;

    slides.forEach((slide, i) => {
      // ✅ تعديل: حساب الإزاحة بطريقة تأخذ "المسار الأقصر" في الاعتبار
      // هذا يضمن أن الحركة دائرية ومتناظرة دائمًا.
      const totalSlides = slides.length;
      const directOffset = i - currentIndex;
      const wrapOffset = directOffset > 0 ? directOffset - totalSlides : directOffset + totalSlides;
      const offset = Math.abs(directOffset) < Math.abs(wrapOffset) ? directOffset : wrapOffset;

      const isActive = offset === 0;

      // حساب التحريك الأفقي والتكبير
      // الشرائح الجانبية تكون أصغر ومزاحة
      const translateX = offset * 40; // 40% من عرض الشريحة
      const scale = isActive ? 1 : 0.7;
      // ✅ جديد: إضافة إزاحة بسيطة على المحور Z لإعطاء عمق ومنع التداخل
      const translateZ = -Math.abs(offset) * 50;

      slide.style.transform = `translateX(${translateX}%) translateZ(${translateZ}px) scale(${scale})`;
      slide.classList.toggle('active', isActive);

      // عند النقر على شريحة جانبية، تنتقل لتصبح هي النشطة
      slide.onclick = () => goToSlide(i);
    });

    dots.forEach((dot, i) => dot.classList.toggle('active', i === currentIndex));
    if (slides.length > 1) {
      resetAutoPlay();
    }
  }

  /**
   * @description تبدأ الحركة التلقائية لشريط التمرير، حيث تنتقل الشرائح كل 4 ثوانٍ.
   * @returns {void}
   * @inner
   */
  function startAutoPlay() {
    if (autoPlayInterval) clearInterval(autoPlayInterval); // مسح المؤقت القديم
    // تغيير الشريحة كل 4 ثوانٍ
    autoPlayInterval = setInterval(() => goToSlide(currentIndex + 1), 4000);
  }

  /**
   * @description توقف الحركة التلقائية لشريط التمرير عن طريق مسح المؤقت.
   * @returns {void}
   * @inner
   */
  function pauseAutoPlay() {
    clearInterval(autoPlayInterval);
  }

  /**
   * @description تعيد ضبط الحركة التلقائية لشريط التمرير عن طريق إيقافها ثم إعادة تشغيلها.
   * @returns {void}
   * @see pauseAutoPlay
   * @see startAutoPlay
   * @inner
   */
  function resetAutoPlay() {
    pauseAutoPlay();
    startAutoPlay();
  }

  // بدء الحركة
  if (slides.length > 0) {
    goToSlide(0); // عرض الشريحة الأولى

    // ✅ جديد: إظهار/إخفاء أزرار التنقل والتحكم في الحركة
    if (slides.length > 1) {
      startAutoPlay();
      prevButton.style.display = 'flex';
      nextButton.style.display = 'flex';

      prevButton.addEventListener('click', () => {
        goToSlide(currentIndex - 1);
      });

      nextButton.addEventListener('click', () => {
        goToSlide(currentIndex + 1);
      });
    } else {
      prevButton.style.display = 'none';
      nextButton.style.display = 'none';
      // ✅ جديد: إخفاء حاوية النقاط إذا كانت هناك صورة واحدة فقط
      dotsContainer.style.display = 'none';
    }
  }

  

}
    </script>